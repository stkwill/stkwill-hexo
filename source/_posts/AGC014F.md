---
title: AGC014F 题解
top: 50
mathjax: true
categories:
  - solution
  - AtCoder
tags:
  - solution
  - AtCoder
date: 2024-02-07 17:29:21
update: 2024-02-07 18:41:31
---

[导航 - 题解](/guide-solution/)

**题面链接：** [AtCoder](https://atcoder.jp/contests/agc014/tasks/agc014_f) [洛谷](https://www.luogu.com.cn/problem/AT_agc014_f) [Virtual Judge](https://vjudge.net/problem/Atcoder-agc014_f)

## 简要题意

有一个长度为 $n$ 的排列，现在你做了几次操作，陈述如下：

找出所有的 $i$ ，满足：对于任意 $1\le j < i, a_j<a_i$

将这些 $a_i$ 移至序列末尾。没有移动的数之间的顺序不变，移动的数之间的顺序也不变

可以证明，在有限次操作后，序列一定会变成 $1,2,3,\cdots,n$ ，你想知道最小的操作次数

## 思路

注意到 $1$ 不会改变其他数是否为 up/low

### 可以考虑从值域 $[2,n]$ 推导到 $[1,n]$

设值域 $[2,n]$ 内元素完成排序需要 $T$ 步

答案为 $T$ / $T+1$ 取决于 $T$ 步后 $1$ 是否处于第一个位置

试着考虑第 $T$ 步时的情况：

- 走完 $T$ 步后 $[2,n]$ 已完成排序

- **引理一：走完 $T-1 (T \ge 1)$ 步后 $2$ 必定不会在第一个位置**
    
证明：若 $2$ 在第一个位置，那么第 $T$ 步 $2$ 必为 up ，又由于走完 $T$ 步后 $2$ 在第一个位置，所以所有数都必须为 up ，那么其实走完 $T-1$ 步时就已经完成排序，与假设值域 $[2,n]$ 答案为 $T$ 矛盾

- 那么走完 $T-1$ 步时，有三个数的位置是关键的： 第一个位置的数 $f$ 与 $1, 2$

此时很难直接观察到判断答案是否增加的方式

#### 所以去观察新东西：第一个位置的数 $f$ 的性质

观察样例3：

```
10
2 10 5 7 3 6 4 9 8 1
```

6次操作后序列分别是：

```
5 7 3 6 4 9 8 1 2 10
3 6 4 8 1 2 5 7 9 10
4 1 2 5 7 3 6 8 9 10
1 2 3 6 4 5 7 8 9 10
4 5 1 2 3 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
```

注意一个非平凡的数字 $4$ 在第一个位置上出现多次

观察它是 up 还是 low

发现这个数当且仅当为 up 的时候处于第一个位置

试着得出结论

**引理二：若一个数 $f$ 某一步时为 up 且不在第一个位置上，那么之后它都不可能在第一个位置上**
    
证明：考虑 $f$ up 时前一个 up 的数 $t$ ，之后 $t < f$ 顺序相邻，除非有一步时 $t$ low, $f$ up ，否则它们不会分开，但是这一步时 $t$ 前必有一数 $x$ 满足 $t<x<f$ ，其中 $x$ 为 $f$ 前一个 up 的数，那么会有新的一个数开始与 $f$ 相邻，也就是说，$f$ 前一个位置始终有一个比 $f$ 小的数，那么 $f$ 就不可能作为第一个位置

得出 **引理二** 后，我们再去考虑那三个关键的数： $f, 1, 2$

我们考虑三个数的相对位置，当走完 $T-1$ 步时，只有三个数相对位置为 $(f, 1, 2)$ 时才有可能走完 $T$ 步时刚好排完序，而且说明这种情况必定可以排好序非常简单

那么考虑这种相对位置的情况可能有哪些情况得来（根据引理二）

发现正好为 $(f, 1, 2)$ 及其循环情况 $(1, 2, f)$ 、 $(2, f, 1)$

证明：

- $(f, 1, 2)$ ：仅有 $f$ 可能为 up ，会转化为 $(1, 2, f)$

- $(1, 2, f)$ ：此时 $1, 2$ up 情况必定相同
    - up up down $\to (f, 1, 2)$
    - down down up $\to (1, 2, f)$
    - up up up 不可能（引理二）

- $(2, f, 1)$ ：此时仅有 $2, f$ 可能 up ，且不能同时 up （引理二）
    - up down down $\to (f, 1, 2)$
    - down up down 前面有一数 $x$ 满足 $2 < x < f$ ，状态 up ，不可能（引理二）

那么只要开始时三个数的相对位置情况正好为 $(f, 1, 2)$ 及其循环情况

又由于 $T-1$ 步后 $f$ 在第一个位置上，此时相对位置必为 $(f, 1, 2)$

那么有了判断条件以后这道题就非常简单了

### 流程

考虑从值域 $[i + 1, n]$ 推导至值域 $[i, n]$

设值域 $[i + 1, n]$ 需要 $T$ 步排序，若 $T>0$ ，$T-1$ 步后第一个位置上数为 $f$

- $T = 0$
    - 若 $pos_i < pos_{i + 1}$ ，$T' \gets 0$
    - 若 $pos_i > pos_{i + 1}$ ，$T' \gets 1, f' \gets i + 1$
- $T > 0$
    - 若 $f, 1, 2$ 起始位置关系为其循环（$(pos_f < pos_1) + (pos_1 < pos_2) + (pos_2 < pos_f) = 2$），$T' \gets T, f' \gets f$
    - 否则，$T' \gets T + 1, f' \gets i + 1$

时间复杂度： $O(n)$

## 代码

<https://atcoder.jp/contests/agc014/submissions/50077200>

<https://www.luogu.com.cn/record/146467107>

```cpp
#include <bits/stdc++.h>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<int> a(n + 1), p(n + 1);
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
        p[a[i]] = i;
    }

    int t = 0, f = n;
    for (int i = n - 1; i >= 1; --i) {
        if (t == 0) {
            if (p[i] < p[f]) {
                f = i;
            } else {
                ++t;
            }
        } else {
            if ((p[f] < p[i]) + (p[i] < p[i + 1]) + (p[i + 1] < p[f]) != 2) {
                ++t;
                f = i + 1;
            }
        }
    }

    std::cout << t << '\n';

    return 0;
}
```
